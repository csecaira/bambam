#!/usr/bin/env python3
# Copyright (C)
#    2007-2008 Don Brown,
#    2010 Spike Burch <spikeb@gmail.com>,
#    2015-2016 Vasya Novikov
#    2018 Olivier Mehani <shtrom+bambam@ssji.net>
#    2018-2024 Marcin Owsiany <marcin@owsiany.pl>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import datetime
import fnmatch
import gettext
import logging
import math
import os
import pygame
from pygame.locals import Color, QUIT, KEYDOWN, MOUSEMOTION, MOUSEBUTTONDOWN, MOUSEBUTTONUP
import random
import sys
import time
import tkinter as tk
from tkinter import *
from textwrap import fill

try:
    import yaml
    _YAML_LOADED = True
except ImportError:
    _YAML_LOADED = False


# noinspection PyPep8Naming
def N_(s): return s


# TRANSLATORS: command string to toggle sound.
# Must not contain spaces, and should be be at least 4 characters long,
# so that it is unlikely to be generated by a keyboard-mashing baby.
# However it is recommended to keep it shorter than 10 characters so that
# it is relatively easy to type by an adult without making mistakes.
SOUND_TOGGLE_STRING = N_('sound')
# TRANSLATORS: command string to toggle sticky mouse button.
# Must not contain spaces, and should be be at least 4 characters long,
# so that it is unlikely to be generated by a keyboard-mashing baby.
# However it is recommended to keep it shorter than 10 characters so that
# it is relatively easy to type by an adult without making mistakes.
MOUSE_TOGGLE_STRING = N_('mouse')
# TRANSLATORS: command string to mute sounds.
# Must not contain spaces, and should be be at least 4 characters long,
# so that it is unlikely to be generated by a keyboard-mashing baby.
# However it is recommended to keep it shorter than 10 characters so that
# it is relatively easy to type by an adult without making mistakes.
MUTE_STRING = N_('mute')
# TRANSLATORS: command string to unmute sounds.
# Must not contain spaces, and should be be at least 4 characters long,
# so that it is unlikely to be generated by a keyboard-mashing baby.
# However it is recommended to keep it shorter than 10 characters so that
# it is relatively easy to type by an adult without making mistakes.
UNMUTE_STRING = N_('unmute')
# TRANSLATORS: command string to quit the game.
# Must not contain spaces, and should be be at least 4 characters long,
# so that it is unlikely to be generated by a keyboard-mashing baby.
# However it is recommended to keep it shorter than 10 characters so that
# it is relatively easy to type by an adult without making mistakes.
QUIT_STRING = N_('quit')


class BambamException(Exception):
    """Represents a bambam-specific exception."""
    pass


class ResourceLoadException(BambamException):
    """Represents a failure to load a resource."""

    def __init__(self, resource, message):
        self._resource = resource
        self._message = message

    def __str__(self):
        return _('Failed to load file "%(file)s": %(message)s') % dict(file=self._resource, message=self._message)


def init_joysticks():
    pygame.joystick.init()
    """
    Initialize all joysticks.
    """
    joystick_count = pygame.joystick.get_count()
    for i in range(joystick_count):
        joystick = pygame.joystick.Joystick(i)
        joystick.init()


def poll_for_any_key_press(clock):
    while True:
        clock.tick(60)
        for event in pygame.event.get():
            if event.type in [QUIT, KEYDOWN, pygame.JOYBUTTONDOWN, MOUSEBUTTONDOWN]:
                return

class Bambam:
    IMAGE_MAX_WIDTH = 700
    _HUE_SPACE = 360

    def get_color(self):
        """
        Return bright color varying over time.
        """
        # Dividing by two results in a rate of change similar to the legacy
        # method of generating current color, based on current time.
        hue = int(self._event_count // 2) % self._HUE_SPACE
        color = Color('white')
        color.hsva = (hue, 100, 100, 100)
        return color

    @classmethod
    def load_image(cls, fullname):
        """
        Load image/, handling setting of the transparency color key.
        """
        try:
            image = pygame.image.load(fullname)

            size_x, size_y = image.get_rect().size
            if size_x > cls.IMAGE_MAX_WIDTH or size_y > cls.IMAGE_MAX_WIDTH:
                new_size_x = cls.IMAGE_MAX_WIDTH
                new_size_y = int(cls.IMAGE_MAX_WIDTH * (float(size_y)/size_x))
                if new_size_y < 1:
                    raise ResourceLoadException(
                        fullname,
                        _("image has height of 0 after resizing to fit within %(width)dx%(height)d pixels") % dict(
                            width=cls.IMAGE_MAX_WIDTH, height=cls.IMAGE_MAX_WIDTH))

                image = pygame.transform.scale(image, (new_size_x, new_size_y))

        except pygame.error as message:
            raise ResourceLoadException(fullname, message)

        return image.convert()

    @classmethod
    def load_sound(cls, name):
        """
        Load sound file in "data/".
        """
        try:
            return pygame.mixer.Sound(name)
        except pygame.error as message:
            raise ResourceLoadException(name, message)

    @classmethod
    def load_items(cls, lst, blacklist, load_function, failure_message):
        """
        Runs load_function on elements of lst unless they are blacklisted.
        Returns a list of (base file name, result) tuples.
        """
        result = []
        errors_encountered = False
        for name in lst:
            if any(fnmatch.fnmatch(name, p) for p in blacklist):
                # TRANSLATORS: "item" can refer to an image or sound file path
                print(_("Skipping blacklisted item %s") % name)
            else:
                try:
                    result.append((os.path.basename(name), load_function(name)))
                except ResourceLoadException as e:
                    print(e, file=sys.stderr)
                    errors_encountered = True
        if not result and errors_encountered:
            raise BambamException(failure_message)
        return result

    def __init__(self):
        self._random = random.Random(os.environ.get('BAMBAM_RANDOM_SEED'))

        self.data_dirs = []
        self.extensions_dirs = []

        self.screen = None
        self.display_height = None
        self.display_width = None

        self.sequence = ""

        self._sound_policies = dict()
        self._image_policies = dict()

        self._event_count = self._random.randint(0, 2 * self._HUE_SPACE - 1)

    def _add_image_policy(self, name, policy):
        self._image_policies[name] = policy

    def _add_sound_policy(self, name, policy):
        self._sound_policies[name] = policy

    def draw_dot(self):
        """
        draw filled circle at mouse position.
        """
        r = 30
        mouse_x, mouse_y = pygame.mouse.get_pos()

        dot = pygame.Surface((2 * r, 2 * r))
        pygame.draw.circle(dot, self.get_color(), (r, r), r, 0)
        dot.set_colorkey(0, pygame.RLEACCEL)

        self.screen.blit(dot, (mouse_x - r, mouse_y - r))
    
    def random_Letter(self): 
        chosenLetterArr = [self.create_A(), self.create_B(), self.create_C(), self.create_D(), self.create_E(), self.create_F(), self.create_G(), self.create_H(), self.create_I(), self.create_L(), self.create_T()] 
        randomIdx = self._random.randint(0, len(chosenLetterArr) - 1)
        return chosenLetterArr [randomIdx] 

    def create_A(self): 
        create_A = [] 
        rect1 = pygame.Rect(700, 200, 100, 100)
        create_A.append(rect1)

        rect2 = pygame.Rect(700, 250, 150, 50)

        rect2 = pygame.Rect(620, 300, 100, 100)
        create_A.append(rect2)

        rect3 = pygame.Rect(780, 300, 100, 100)
        create_A.append(rect3)

        rect4 = pygame.Rect(550, 400, 100, 100)
        create_A.append(rect4)

        rect5 = pygame.Rect(850, 400, 100, 100)
        create_A.append(rect5)

        rect6 = pygame.Rect(500, 500, 100, 100)
        create_A.append(rect6)

        rect7 = pygame.Rect(900, 500, 100, 100)
        create_A.append(rect7)

        #STARTING THE HORIZONTAL LINE 
        rect8 = pygame.Rect(600, 500, 100, 100)
        create_A.append(rect8)

        rect9 = pygame.Rect(700, 500, 100, 100)
        create_A.append(rect9)

        rect10 = pygame.Rect(800, 500, 100, 100)
        create_A.append(rect10)
        #ENDING THE HORIZONTAL LINE 

        rect11 = pygame.Rect(470, 600, 100, 100)
        create_A.append(rect11)

        rect12 = pygame.Rect(930, 600, 100, 100)
        create_A.append(rect12)

        rect13 = pygame.Rect(420, 700, 100, 100)
        create_A.append(rect13)

        rect14 = pygame.Rect(980, 700, 100, 100)
        create_A.append(rect14)

        return create_A

    def create_B(self):
        create_B = [] 
        rect1 = pygame.Rect(500, 200, 100, 100)
        create_B.append(rect1)
        
        rect2 = pygame.Rect(600, 200, 100, 100)
        create_B.append(rect2)

        rect3 = pygame.Rect(600, 200, 100, 100)
        create_B.append(rect3)

        rect4 = pygame.Rect(700, 200, 100, 100)
        create_B.append(rect4)
        
        rect5 = pygame.Rect(760, 230, 90, 90)
        create_B.append(rect5)

        rect6 = pygame.Rect(810, 300, 100, 100)
        create_B.append(rect6)

        rect7 = pygame.Rect(760, 370, 90, 90)
        create_B.append(rect7)

        rect8 = pygame.Rect(700, 420, 100, 100)
        create_B.append(rect8)

        rect9 = pygame.Rect(600, 420, 100, 100)
        create_B.append(rect9)

        rect10 = pygame.Rect(500, 420, 100, 100)
        create_B.append(rect10)

        rect11 = pygame.Rect(760, 510, 90, 90)
        create_B.append(rect11)

        rect12 = pygame.Rect(810, 590, 100, 100)
        create_B.append(rect12) 

        rect13 = pygame.Rect(760, 650, 90, 90)
        create_B.append(rect13)

        rect14 = pygame.Rect(700, 700, 100, 100)
        create_B.append(rect14)

        rect15 = pygame.Rect(600, 700, 100, 100)
        create_B.append(rect15)

        rect15 = pygame.Rect(500, 700, 100, 100)
        create_B.append(rect15)

        rect16 = pygame.Rect(500, 600, 100, 100) 
        create_B.append(rect16)

        rect17 = pygame.Rect(500, 500, 100, 100)
        create_B.append(rect17)

        rect18 = pygame.Rect(500, 400, 100, 100)
        create_B.append(rect18)

        rect19 = pygame.Rect(500, 300, 100, 100)
        create_B.append(rect19)

        return create_B 
    
    def create_C(self): 
        create_C = [] 
        rect1 = pygame.Rect(450, 230, 100, 100)
        create_C.append(rect1)

        rect2 = pygame.Rect(550, 200, 100, 100)
        create_C.append(rect2)

        rect3 = pygame.Rect(650, 200, 100, 100)
        create_C.append(rect3)

        rect4 = pygame.Rect(750, 200, 100, 100)
        create_C.append(rect4)

        rect5 = pygame.Rect(400, 300, 100, 100)
        create_C.append(rect5)

        rect6 = pygame.Rect(350, 400, 100, 100)
        create_C.append(rect6)

        rect7 = pygame.Rect(350, 500, 100, 100)
        create_C.append(rect7)

        rect8 = pygame.Rect(400, 600, 100, 100)
        create_C.append(rect8)
    
        rect9 = pygame.Rect(450, 650, 100, 100)
        create_C.append(rect9)

        rect10 = pygame.Rect(550, 650, 100, 100)
        create_C.append(rect10)

        rect11 = pygame.Rect(650, 650, 100, 100)
        create_C.append(rect11)

        rect12 = pygame.Rect(750, 650, 100, 100)
        create_C.append(rect12)
        
        return create_C

    def create_D(self): 
        create_D = [] 
        rect1 = pygame.Rect(400, 200, 100, 100)
        create_D.append(rect1)

        rect2 = pygame.Rect(400, 300, 100, 100)
        create_D.append(rect2)

        rect3 = pygame.Rect(400, 400, 100, 100)
        create_D.append(rect3)

        rect4 = pygame.Rect(400, 500, 100, 100)
        create_D.append(rect4)

        rect5 = pygame.Rect(400, 600, 100, 100)
        create_D.append(rect5)

        #line 

        rect6 = pygame.Rect(500, 200, 100, 100)
        create_D.append(rect6)

        rect7 = pygame.Rect(600, 200, 100, 100)
        create_D.append(rect7)

        #more

        rect8 = pygame.Rect(680, 250, 100, 100)
        create_D.append(rect8)

        rect9 = pygame.Rect(680, 350, 100, 100)
        create_D.append(rect9)

        rect10 = pygame.Rect(680, 450, 100, 100)
        create_D.append(rect10)

        rect11 = pygame.Rect(600, 500, 100, 100)
        create_D.append(rect11)

        rect12 = pygame.Rect(550, 580, 100, 100)
        create_D.append(rect12)

        rect13 = pygame.Rect(500, 600, 100, 100)
        create_D.append(rect13)


        return create_D 
    
    def create_E(self): 
        create_E = [] 
        rect1 = pygame.Rect(400, 200, 100, 100)
        create_E.append(rect1)

        rect2 = pygame.Rect(500, 200, 100, 100)
        create_E.append(rect2)

        rect3 = pygame.Rect(600, 200, 100, 100)
        create_E.append(rect3)

        rect13 = pygame.Rect(700, 200, 100, 100)
        create_E.append(rect13)

        rect4 = pygame.Rect(400, 300, 100, 100)
        create_E.append(rect4)

        rect5 = pygame.Rect(400, 400, 100, 100)
        create_E.append(rect5)

        rect6 = pygame.Rect(400, 500, 100, 100)
        create_E.append(rect6)

        rect7 = pygame.Rect(400, 600, 100, 100)
        create_E.append(rect7)

        rect8 = pygame.Rect(400, 700, 100, 100)
        create_E.append(rect8)

        rect9 = pygame.Rect(500, 700, 100, 100)
        create_E.append(rect9)

        rect10 = pygame.Rect(600, 700, 100, 100)
        create_E.append(rect10)

        rect11 = pygame.Rect(700, 700, 100, 100)
        create_E.append(rect11)

        rect12 = pygame.Rect(500, 450, 100, 100)
        create_E.append(rect12)

        rect13 = pygame.Rect(600, 450, 100, 100)
        create_E.append(rect13)
        return create_E 
    
    def create_F(self): 
        create_F = [] 
        rect1 = pygame.Rect(400, 200, 100, 100)
        create_F.append(rect1)

        rect2 = pygame.Rect(500, 200, 100, 100)
        create_F.append(rect2)

        rect3 = pygame.Rect(600, 200, 100, 100)
        create_F.append(rect3)

        rect4 = pygame.Rect(700, 200, 100, 100)
        create_F.append(rect4)
        
        rect5 = pygame.Rect(400, 300, 100, 100)
        create_F.append(rect5)

        rect6 = pygame.Rect(400, 400, 100, 100)
        create_F.append(rect6)

        rect7 = pygame.Rect(400, 500, 100, 100)
        create_F.append(rect7)

        rect8 = pygame.Rect(400, 600, 100, 100)
        create_F.append(rect8)

        rect9 = pygame.Rect(400, 700, 100, 100)
        create_F.append(rect9)

        rect10 = pygame.Rect(500, 450, 100, 100)
        create_F.append(rect10)

        rect11 = pygame.Rect(600, 450, 100, 100)
        create_F.append(rect11)

        return create_F 

    def create_G(self): 
        create_G = [] 
        
        rect1 = pygame.Rect(500, 200, 100, 100)
        create_G.append(rect1)

        rect2 = pygame.Rect(600, 200, 100, 100) 
        create_G.append(rect2)

        rect3 = pygame.Rect(700, 200, 100, 100)  
        create_G.append(rect3)

        rect11 = pygame.Rect(800, 200, 100, 100)
        create_G.append(rect11)

        rect4 = pygame.Rect(450, 280, 100, 100)
        create_G.append(rect4)

        rect5 = pygame.Rect(420, 350, 100, 100)
        create_G.append(rect5)

        rect6 = pygame.Rect(420, 450, 100, 100)
        create_G.append(rect6)

        rect7 = pygame.Rect(420, 550, 100, 100)
        create_G.append(rect7)

        rect8 = pygame.Rect(450, 650, 100, 100)
        create_G.append(rect8)

        rect9 = pygame.Rect(500, 700, 100, 100)
        create_G.append(rect9)

        rect10 = pygame.Rect(600, 700, 100, 100)
        create_G.append(rect10)

        rect12 = pygame.Rect(700, 700, 100, 100)
        create_G.append(rect12)

        rect13 = pygame.Rect(800, 700, 100, 100)
        create_G.append(rect13)

        rect14 = pygame.Rect(830, 650, 100, 100)
        create_G.append(rect14)

        rect15 = pygame.Rect(830, 550, 100, 100)
        create_G.append(rect15)

        rect16 = pygame.Rect(730, 510, 100, 100)
        create_G.append(rect16)

        rect17 = pygame.Rect(630, 510, 100, 100)
        create_G.append(rect17)

        return create_G
    
    def create_H(self):
        create_H = [] 
        rect1 = pygame.Rect(400, 200, 100, 100)
        create_H.append(rect1)

        rect2 = pygame.Rect(400, 300, 100, 100)
        create_H.append(rect2)

        rect3 = pygame.Rect(400, 400, 100, 100)
        create_H.append(rect3)

        rect4 = pygame.Rect(400, 500, 100, 100)
        create_H.append(rect4)

        rect5 = pygame.Rect(400, 600, 100, 100)
        create_H.append(rect5)

        rect6 = pygame.Rect(400, 700, 100, 100)
        create_H.append(rect6)

        rect7 = pygame.Rect(700, 200, 100, 100)
        create_H.append(rect7)

        rect8 = pygame.Rect(700, 300, 100, 100)
        create_H.append(rect8)

        rect9 = pygame.Rect(700, 400, 100, 100)
        create_H.append(rect9)

        rect10 = pygame.Rect(700, 500, 100, 100)
        create_H.append(rect10)

        rect11 = pygame.Rect(700, 600, 100, 100)
        create_H.append(rect11)

        rect12 = pygame.Rect(700, 700, 100, 100)
        create_H.append(rect12)

        rect13 = pygame.Rect(500, 450, 100, 100)
        create_H.append(rect13)

        rect14 = pygame.Rect(600, 450, 100,100)
        create_H.append(rect14)

 
        return create_H

    def create_I(self): 
        create_I = []
        rect1 = pygame.Rect(500, 200, 100, 100)
        create_I.append(rect1)
        rect2 = pygame.Rect(600, 200, 100, 100)
        create_I.append(rect2)
        rect3 = pygame.Rect(700, 200, 100, 100)
        create_I.append(rect3)
        rect4 = pygame.Rect(800, 200, 100, 100)
        create_I.append(rect4)
        rect5 = pygame.Rect(900, 200, 100, 100)
        create_I.append(rect5)
        rect6 = pygame.Rect(700, 300, 100, 100)
        create_I.append(rect6)
        rect7 = pygame.Rect(700, 400, 100, 100)
        create_I.append(rect7)
        rect8 = pygame.Rect(700, 500, 100, 100)
        create_I.append(rect8)
        rect9 = pygame.Rect(700, 600, 100, 100)
        create_I.append(rect9)
        rect10 = pygame.Rect(700, 700, 100, 100)
        create_I.append(rect10)
        
        rect11 = pygame.Rect(500, 700, 100, 100)
        create_I.append(rect11)
        rect12 = pygame.Rect(600, 700, 100, 100)
        create_I.append(rect12)
        rect13 = pygame.Rect(700, 700, 100, 100)
        create_I.append(rect13)
        rect14 = pygame.Rect(800, 700, 100, 100)
        create_I.append(rect14)
        rect15 = pygame.Rect(900, 700, 100, 100)
        create_I.append(rect15)
        return create_I
   
    def create_L(self): 
        creatingL = [] 
        rect1 = pygame.Rect(600, 200, 100, 100)
        creatingL.append(rect1)
        rect2 = pygame.Rect(600, 300, 100, 100)
        creatingL.append(rect2)
        rect3 = pygame.Rect(600, 400, 100, 100)
        creatingL.append(rect3)
        rect4 = pygame.Rect(600, 500, 100, 100)
        creatingL.append(rect4)
        rect5 = pygame.Rect(600, 600, 100, 100)
        creatingL.append(rect5)
        #the horizontal line
        rect8 = pygame.Rect(700, 600, 100, 100) 
        creatingL.append(rect8)
        rect9 = pygame.Rect(800, 600, 100, 100)
        creatingL.append(rect9)
        rect10 = pygame.Rect(900, 600, 100, 100)
        creatingL.append(rect10)
        return creatingL

    def create_T(self): 
        creatingT = [] 
        rect1 = pygame.Rect(500, 200, 100, 100)
        creatingT.append(rect1)
        rect2 = pygame.Rect(600, 200, 100, 100)
        creatingT.append(rect2)
        rect3 = pygame.Rect(700, 200, 100, 100)
        creatingT.append(rect3)
        rect4 = pygame.Rect(800, 200, 100, 100) 
        creatingT.append(rect4)
        rect5 = pygame.Rect(900, 200, 100, 100)
        creatingT.append(rect5)
        rect6 = pygame.Rect(700, 300, 100, 100)
        creatingT.append(rect6)
        rect7 = pygame.Rect(700, 400, 100, 100)
        creatingT.append(rect7)
        rect8 = pygame.Rect(700, 500, 100, 100)
        creatingT.append(rect8)
        rect9 = pygame.Rect(700, 600, 100, 100)
        creatingT.append(rect9)
        rect10 = pygame.Rect(700, 700, 100, 100)
        creatingT.append(rect10)
        return creatingT

    def tracing_game(self):
        """
        Creates a tracing game
        """
        #aestheic variables: 
        background_color = (255, 235, 149)
        textFont = pygame.font.SysFont("arial", 50, True, False)
        textFontColor = (0, 0, 0)
        textFontColor2 = (255, 255, 255)
        buttonColor1 = (255, 14, 49)
        buttonColor2 = (0, 4, 198)
        buttonColor3 = (48, 25, 52)
        letterColor = (204, 25, 174)
        userCirclesColor = (122, 13, 199)

        traced_set = set() 
        startTime = -1 

        surface = pygame.display.set_mode((self.display_width, self.display_height))
        pygame.display.set_caption('Tracing')
        surface.fill(background_color)

        tracingText = "TRACE THE FOLLOWING LETTER: "
        tracingLabel = textFont.render(tracingText, 1, textFontColor)
        surface.blit(tracingLabel, (100, 80))

        quitButton = pygame.Rect(1200, 50, 300, 150)
        pygame.draw.rect(surface, buttonColor1, quitButton)
        quitText = "QUIT"
        quitLabel = textFont.render(quitText, 1, textFontColor)
        surface.blit(quitLabel, (1290, 100)) 

        newLetterButton = pygame.Rect(1200, 250, 300, 150)
        pygame.draw.rect(surface, buttonColor2, newLetterButton)
        newLetterText = "NEW"
        newLetterLabel = textFont.render(newLetterText, 1, textFontColor2)
        surface.blit(newLetterLabel, (1290, 300))

        eraseButton = pygame.Rect(1200, 450, 300, 150)
        pygame.draw.rect(surface, buttonColor3, eraseButton)
        eraseText = "ERASE"
        eraseLabel = textFont.render(eraseText, 1, textFontColor2)
        surface.blit(eraseLabel, (1280, 500))

        pygame.display.flip()

        #randomShapeArr = self.random_Letter()
        randomShapeArr = self.create_H()
        for i in range(len(randomShapeArr)): 
            pygame.draw.rect(surface, letterColor, randomShapeArr[i])
        pygame.display.update()

        #important variables for the loop:
        run = True 
        userDrawing = False
        controllingDrawing = False

        while run:
            for event in pygame.event.get():
                if event.type == pygame.MOUSEBUTTONDOWN:
                    resetLetter = False
                    if newLetterButton.collidepoint(event.pos): 
                        resetLetter = True 

                    if quitButton.collidepoint(event.pos): 
                        run = False
                    elif newLetterButton.collidepoint(event.pos) or eraseButton.collidepoint(event.pos): 
                        startTime = -1
                        traced_set = set()
                        surface.fill(background_color)
                        controllingDrawing = False

                        surface.blit(tracingLabel, (100, 80))
                        pygame.draw.rect(surface, buttonColor1, quitButton)
                        surface.blit(quitLabel, (1290, 100)) 

                        pygame.draw.rect(surface, buttonColor2, newLetterButton)
                        surface.blit(newLetterLabel, (1290, 300))

                        pygame.draw.rect(surface, buttonColor3, eraseButton)
                        surface.blit(eraseLabel, (1280, 500))

                        pygame.display.flip()
                        
                        if resetLetter: 
                            randomShapeArr = self.random_Letter()
                            resetLetter = False

                        for j in range(len(randomShapeArr)):  
                            pygame.draw.rect(surface, letterColor, randomShapeArr[j])

                        pygame.display.update()
                    elif not controllingDrawing: 
                        userDrawing = True
                elif event.type == pygame.MOUSEBUTTONUP: 
                    userDrawing = False
                elif event.type == pygame.MOUSEMOTION and userDrawing:
                    pygame.draw.circle(surface, userCirclesColor, event.pos, 60)
                    pygame.display.update()

                    circleRect = pygame.Rect(event.pos[0] - 50, event.pos[1] - 50, 70, 70)

                    for k in randomShapeArr:
                        miniRect = pygame.Rect(k.centerx, k.centery, 5, 5)
                        if circleRect.colliderect(miniRect) and id(k) not in traced_set:
                            traced_set.add(id(k))  

                    if len(traced_set) == len(randomShapeArr):
                        #print("letter finished")
                        userDrawing = False
                        controllingDrawing = True

                        pygame.time.delay(1000)
                        congratsBackground = pygame.Rect(500, 400, 600, 150)
                        pygame.draw.rect(surface, (255, 140, 0), congratsBackground)
                        congratsText = "LETTER FINISHED!"
                        congratsLabel = textFont.render(congratsText, 1, textFontColor)
                        surface.blit(congratsLabel, (600, 450)) 
                        pygame.display.update() 

        self.screen.blit(self.background, (0, 0))
        pygame.display.flip()

    def read_aloud_game(self):
        """
        Creates a read aloud game
        """
        readingFont = pygame.font.SysFont("arial", 50)
        pygame.mixer.init() 
        surface = pygame.display.set_mode((self.display_width, self.display_height))
        pygame.display.set_caption('Read Aloud')
        surface.fill((255,255,197))

        #button to generate a new image:
        generateButton = pygame.Rect(630, 750, 150, 80)
        pygame.draw.rect(surface, "blue", generateButton)
        generateText = "NEW"
        generateLabel = readingFont.render(generateText, 1, (255, 255, 255))
        surface.blit(generateLabel, (660, 760))

        quitButton = pygame.Rect(780, 750, 150, 80)
        pygame.draw.rect(surface, "red", quitButton)
        quitText = "QUIT"
        quitLabel = readingFont.render(quitText, 1, (0, 0, 0))
        surface.blit(quitLabel, (805, 760))
        pygame.display.flip()

        soundArrNames = ["turtleSound.ogg", "sunSound.ogg", "starSound.ogg", "sheepSound.ogg", "pigSound.ogg", "moonSound.ogg", "flowerSound.ogg", "duckSound.ogg", "dogSound.ogg", "cowSound.ogg", "chickenSound.ogg", "catSound.ogg", "bunnySound.ogg", "birdSound.ogg"]
        imagesArrNames = ["turtle.gif", "sun.gif", "star2.gif", "sheep.gif", "pig.gif", "moon.gif", "flower.gif", "duck.gif", "dog.gif", "cow.gif", "chicken.gif", "cat.gif", "bunny.gif", "bird.gif"] 
        previousImgIdx = 0
        currentImgIdx = 0 

        run = True 
        while run: 
            surface.fill((255, 255, 197))
            generateButton = pygame.Rect(630, 750, 150, 80)
            pygame.draw.rect(surface, "blue", generateButton)
            generateText = "NEW"
            generateLabel = readingFont.render(generateText, 1, (255, 255, 255))
            surface.blit(generateLabel, (660, 760))

            quitButton = pygame.Rect(780, 750, 150, 80)
            pygame.draw.rect(surface, "red", quitButton)
            quitText = "QUIT"
            quitLabel = readingFont.render(quitText, 1, (0, 0, 0))
            surface.blit(quitLabel, (805, 760))
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    run = False
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    if generateButton.collidepoint(event.pos): 
                        currentImgIdx = self._random.randint(0, len(imagesArrNames) - 1)
                        while (previousImgIdx == currentImgIdx): 
                            currentImgIdx = self._random.randint(0, len(imagesArrNames) - 1)
                        previousImgIdx = currentImgIdx  
                        displayImg = pygame.image.load(imagesArrNames[currentImgIdx])
                        self.screen.blit(displayImg,(550, 100)) 
                        pygame.mixer.music.load(soundArrNames[currentImgIdx])
                        pygame.mixer.music.play()
                        pygame.display.update()
                    if quitButton.collidepoint(event.pos):
                        run = False
        pygame.display.update()
        self.screen.blit(self.background, (0, 0))
        pygame.display.flip()
    
    def random_coords(self):
        """
        Generates random coordinates for both rectangles in a matched pair
        """
        coordsArr = []
        padding_x = 50
        padding_y = 200
        rect_width = 100
        rect_height = 150

        x1 = self._random.randint(padding_x, self.display_width - rect_width - padding_x)
        y1 = self._random.randint(padding_y, self.display_height - rect_height - padding_y)

        while True:
            x2 = self._random.randint(padding_x, self.display_width - rect_width - padding_x)
            y2 = self._random.randint(padding_y, self.display_height - rect_height - padding_y)

            # Check if the rectangles overlap
            rect1 = pygame.Rect(x1, y1, rect_width, rect_height)
            rect2 = pygame.Rect(x2, y2, rect_width, rect_height)
            if not rect1.colliderect(rect2):
                break

        coordsArr.extend([x1, y1, x2, y2])
        return coordsArr
    
    def creatingRectangleArr(self, num, colorsArr):
        """
        Creates a rectangle arr for the matching pairs for the matching game
        """
        rectangleArr = []
        rectColors = list(colorsArr.keys())[:num]

        for color in rectColors:
            rect1_coords = self.random_coords()
            rect2_coords = self.random_coords()
            
            rect1 = pygame.Rect(rect1_coords[0], rect1_coords[1], 100, 150)
            rect2 = pygame.Rect(rect2_coords[0], rect2_coords[1], 100, 150)
            
            rectangleArr.append([rect1, color])
            rectangleArr.append([rect2, color])
        return rectangleArr
    
    def matching_game(self):
        """
        Runs a matching game that runs for 10 rounds, with each round increasing matched pairs by 1
        """
        matched_pairs = 0
        myfont = pygame.font.SysFont("arial", 50, True, False)
        rounds = 1
        active_box = None
        matched_set = set()

        pygame.init()
        surface = pygame.display.set_mode((self.display_width, self.display_height))
        pygame.display.set_caption('Matching Game')

        background_color = (255, 184, 238)
        surface.fill(background_color)
        colors = {"purple": (128, 0, 128), "red": (255, 0, 0), "white": (255, 255, 255), "yellow": (255, 255, 0), "blue": (0, 0, 255), "green": (0, 255, 0), "orange": (255, 165, 0), "brown": (150, 75, 0), "magenta": (165, 32, 109), "black": (0, 0, 0)}
        shapes_Arr = self.creatingRectangleArr(rounds, colors) 
        starIMG = pygame.image.load('star.gif')

        run = True
        dragging = False
        startTime = -1

        while run:
            surface.fill(background_color)
            quitButton = pygame.Rect(1200, 50, 300, 150)
            pygame.draw.rect(surface, "red", quitButton)
            quitText = "QUIT"
            quitLabel = myfont.render(quitText, 1, (255, 255, 255))
            surface.blit(quitLabel, (1285,100))

            # Display stars for matched pairs
            for i in range(matched_pairs):
                surface.blit(starIMG, ((i * 90 + 100), 50))

            # Display star count
            starsText = "STARS: " + str(matched_pairs)
            starsLabel = myfont.render(starsText, True, (0, 0, 0))
            surface.blit(starsLabel, (120, 150))

            # Draw all rectangles
            for rect, color in shapes_Arr:
                pygame.draw.rect(surface, colors[color], rect)
            pygame.display.update()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    run = False
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    if quitButton.collidepoint(event.pos): 
                        run = False
                    if event.button == 1:  
                        for num, (rect, color) in enumerate(shapes_Arr):
                            if rect.collidepoint(event.pos):
                                active_box = num
                                dragging = True
                                break

                elif event.type == pygame.MOUSEBUTTONUP:
                    if event.button == 1 and active_box is not None:
                        dragging = False
                        active_box = None

                elif event.type == pygame.MOUSEMOTION and dragging and active_box is not None:
                    shapes_Arr[active_box][0].move_ip(event.rel)
                    rect1, color1 = shapes_Arr[active_box]
                    for num, (rect2, color2) in enumerate(shapes_Arr):
                        if num != active_box and (active_box, num) not in matched_set and (num, active_box) not in matched_set:
                            if rect1.colliderect(rect2) and color1 == color2:
                                matched_pairs += 1
                                matched_set.add((active_box, num))
                                break

            if matched_pairs == rounds:  
                if startTime == -1:
                    startTime = datetime.datetime.now()
                elif (datetime.datetime.now() - startTime).total_seconds() > 5:
                    matched_pairs = 0
                    matched_set.clear()
                    startTime = -1
                    rounds += 1  
                    shapes_Arr = self.creatingRectangleArr(rounds, colors)
                    
            # 10 rounds max
            if rounds > 10:
                run = False

        surface.blit(starIMG, (50, (4 * 90 + 20)))
        pygame.display.update()
        self.screen.blit(self.background, (0, 0))
        pygame.display.flip()

    def process_keypress(self, event):
        """
        Processes events from keyboard or joystick.
        """
        if event.type == KEYDOWN and event.unicode == "1": 
            self.matching_game()

        # temp for the random sound generator 
        elif event.type == KEYDOWN and event.unicode == "2": 
            #print("key 2 was pressed | Second Game started")
            self.read_aloud_game() 

        elif event.type == KEYDOWN and event.unicode == "3":
            #print("key 3 was pressed | Third Game started")
            self.tracing_game() 

        elif event.type == KEYDOWN and event.unicode.isalpha():
            self._maybe_process_command(event.unicode)
            sound, img = self._select_response(event)
            if sound and not self.sound_muted:
                sound.play()
                self._display_image(img)
                pygame.display.flip()

        # Clear the screen 10% of the time
        if self._random.randint(0, 10) == 1:
            logging.debug('Clearing screen.')
            self.screen.blit(self.background, (0, 0))
            pygame.display.flip()  

    def _maybe_process_command(self, last_keypress: str):
        self.sequence += last_keypress.lower()         
        if self.sequence.find(_(QUIT_STRING).lower()) > -1:
            sys.exit(0)
        if self.sequence.find(_(MOUSE_TOGGLE_STRING).lower()) > -1:
            self._sticky_mouse = not self._sticky_mouse
            self.sequence = ''
            return
        if not self._sound_enabled:
            return
        if self.sequence.find(_(UNMUTE_STRING).lower()) > -1:
            self.sound_muted = False
            self.sequence = ''
        elif self.sequence.find(_(MUTE_STRING).lower()) > -1:
            self.sound_muted = True
            pygame.mixer.fadeout(1000)
            self.sequence = ''
        elif self.sequence.find(_(SOUND_TOGGLE_STRING).lower()) > -1:
            self.sound_muted = not self.sound_muted
            self.sequence = ''

    def _select_response(self, event):
        logging.debug('Selecting response for event %s.', event)
        sound = _map_and_select(event, self._sound_mapper, self._sound_policies) if self._sound_enabled else None
        image = _map_and_select(event, self._image_mapper, self._image_policies)
        return sound, image

    def _display_image(self, img):
        """
        Prints an image at a random location.
        """
        w = self._random.randint(0, self.display_width - img.get_width() - 1)
        h = self._random.randint(0, self.display_height - img.get_height() - 1)
        logging.debug('Blitting at %s image %s', (w, h), img)
        self.screen.blit(img, (w, h))

    def glob_dir(self, path, suffixes):
        files = []
        for file_name in os.listdir(path):
            path_name = os.path.join(path, file_name)
            if os.path.isdir(path_name):
                files.extend(self.glob_dir(path_name, suffixes))
            else:
                for ext in suffixes:
                    if path_name.lower().endswith(ext):
                        files.append(path_name)
                        break
        return files

    def glob_data(self, suffixes):
        """
        Search for files ending with any of the provided suffixes in data directories.
        Eg: suffixes = ['.abc'] will be similar to `ls *.abc` in the configured
        data dirs. Matching will be case-insensitive.
        """
        suffixes = [x.lower() for x in suffixes]
        file_list = []
        for data_dir in self.data_dirs:
            file_list.extend(self.glob_dir(data_dir, suffixes))
        return file_list

    def glob_extension(self, suffixes, extension_name):
        """
        Search for files ending with any of the provided suffixes in extension directories.
        Eg: suffixes = ['.abc'] will be similar to `ls *.abc` in the configured
        extension directories. Matching will be case-insensitive.
        """
        suffixes = [s.lower() for s in suffixes]
        file_list = []
        for extension_dir in self.extensions_dirs:
            extension_subdir = os.path.join(extension_dir, extension_name)
            file_list.extend(self.glob_dir(extension_subdir, suffixes))
        return file_list

    def _prepare_screen(self, args):
        # determine display resolution
        display_info = pygame.display.Info()
        self.display_width = display_info.current_w
        self.display_height = display_info.current_h

        self.screen = pygame.display.get_surface()

        # TRANSLATORS: placeholder is for a space-separated list of supported command strings (more than one).
        caption_format = _("Commands: %s")
        if self._sound_enabled:
            command_strings = [QUIT_STRING, SOUND_TOGGLE_STRING, MOUSE_TOGGLE_STRING]
        else:
            command_strings = [QUIT_STRING, MOUSE_TOGGLE_STRING]
        self.background_color = (0, 0, 0) if args.dark else (250, 250, 250)
        # noinspection PyArgumentList
        self.background = pygame.Surface(self.screen.get_size()).convert()
        self.background.fill(self.background_color)
        caption_font = pygame.font.SysFont(None, 20)
        caption_label = caption_font.render(
            caption_format % " ".join(_(s).lower() for s in command_strings),
            True,
            (210, 210, 210),  # Light grey.
            self.background_color)
        caption_rect = caption_label.get_rect()
        caption_rect.x = 15
        caption_rect.y = 10
        self.background.blit(caption_label, caption_rect)

        self.screen.blit(self.background, (0, 0))
        pygame.display.flip()

    def _prepare_wayland_warning(self):
        font_size = 80
        caption_font = pygame.font.SysFont(None, font_size)
        for i, msg in enumerate([
                _("Error: Wayland display detected."),
                _("Cannot lock the keyboard safely."),
                "",
                _("Press any key to quit.")]):
            caption_label = caption_font.render(
                msg,
                True,
                (250, 0, 0),
                self.background_color)
            caption_rect = caption_label.get_rect()
            caption_rect.x = 150
            caption_rect.y = 100 + (i * font_size)
            self.screen.blit(caption_label, caption_rect)
        pygame.display.flip()

    def _prepare_welcome_message(self, dedicated_session):
        left_message_margin = 75
        header_font = pygame.font.SysFont(None, 56)
        header_text = _("Please read the following important information!")
        header_label = header_font.render(header_text, True, pygame.Color('blue'), self.background_color)
        header_rect = header_label.get_rect()
        header_rect.x = left_message_margin
        header_rect.y = 100
        self.screen.blit(header_label, header_rect)
        header_padding = 20

        text_font_size = 36

        # Draw an arrow starting next to second/third line of text (the text that speaks about the commands)...
        arrow_start = (header_rect.x, int(header_rect.y + header_rect.height + header_padding + text_font_size * 1.5))
        # ... and ending below the list of commands.
        arrow_end = (30, 30)

        arrow_rect = pygame.Rect(arrow_end, (arrow_start[0] - arrow_end[0], arrow_start[1] - arrow_end[1]))
        # The arc is a quarter of an elipse, so the elipse bounds are four times the size of the arrow arc bounds.
        above_arrow_rect = pygame.Rect(arrow_rect)
        above_arrow_rect.bottomleft = arrow_rect.topleft
        east_of_arrow_rect = pygame.Rect(arrow_rect)
        east_of_arrow_rect.bottomleft = arrow_rect.bottomright
        elipse_bounds = pygame.Rect(above_arrow_rect.topleft, (arrow_rect.width*2, arrow_rect.height*2))

        arrow_color = pygame.Color('red')
        arrow_width = 8
        pygame.draw.arc(self.screen, arrow_color, elipse_bounds, math.pi, 3*math.pi/2, arrow_width)
        # Account for the width of the arrow arc.
        arrow_head_start = (arrow_end[0] + int(arrow_width / 2)-1, arrow_end[1])
        arrow_head_end1 = (arrow_head_start[0] - 20, arrow_head_start[1] + 40)
        arrow_head_end2 = (arrow_head_start[0] + 20, arrow_head_start[1] + 40)
        pygame.draw.line(self.screen, arrow_color, arrow_head_start, arrow_head_end1, arrow_width)
        pygame.draw.line(self.screen, arrow_color, arrow_head_start, arrow_head_end2, arrow_width)

        text_font = pygame.font.SysFont(None, text_font_size)
        texts = []
        # TRANSLATORS: the substituted word will be the translated command for quitting the game.
        texts.append(_("To quit the game after it starts, "
                       "directly type the word %s on the keyboard.") % _(QUIT_STRING).lower())
        if self._sound_enabled:
            # TRANSLATORS: "this" means the word quit from the preceding message, in this context.
            texts.append(_("This, and other available commands are mentioned "
                           "in the upper left-hand corner of the window."))
        else:
            # TRANSLATORS: "this" means the word quit from the preceding message, in this context.
            texts.append(_("This command is mentioned in the upper left-hand corner of the window."))
        texts.append("")
        texts.append(_(
            "The game tries to grab the keyboard and mouse pointer focus, "
            "to keep your child from causing damage to your files. "
            "Keys 1, 2, 3 trigger specific minigames: matching, read aloud, and tracing"))
        if dedicated_session:
            texts.append(_(
                "The game is now running in a dedicated login session, which provides some additional safety. "
                "However it may still be possible for the child to accidentally quit the game, "
                "or swich to a different virtual terminal (for example using CTRL+ALT+Fx)."))
            texts.append("")
            texts.append(_(
                "Make sure other user sessions (if any) are locked with a password, "
                "if leaving your child unattended with the game."))
        else:
            texts.append(_(
                "However in some environments it may be possible for the child to exit or "
                "switch away from the game by using a special key combination. "
                "The exact mechanism depends on your graphical environment, window manager, etc. "
                "Examples include the Super (also known as Windows) key, function key combinations (CTRL+ALT+Fx) or "
                "hot corners when using the mouse."))
            texts.append("")
            texts.append(_("We recommend to NOT LEAVE YOUR CHILD UNATTENDED with the game."))
            texts.append(_(
                "Please consider using a dedicated BamBam session instead "
                "(look for a gear icon when logging in), which is safer."))
        texts.append("")
        texts.append("")
        texts.append(_("Press any key or mouse button to start the game now."))
        prev_rect = header_rect
        prev_rect.y += header_padding
        for paragraph in texts:
            for line in fill(paragraph, 70).split("\n"):
                text_label = text_font.render(line, True, pygame.Color('lightblue'), self.background_color)
                text_rect = text_label.get_rect()
                text_rect.x = left_message_margin
                text_rect.y = prev_rect.y + prev_rect.height
                self.screen.blit(text_label, text_rect)
                prev_rect = text_rect
        pygame.display.flip()

    def _add_base_dir(self, base_dir):
        """
        Add base_dir as a possible base directory for bambam data files.
        """
        data_subdir = os.path.join(base_dir, 'data')
        if os.path.isdir(data_subdir):
            print(_('Using data directory %s') % data_subdir)
            self.data_dirs.append(data_subdir)

        extensions_subdir = os.path.join(base_dir, 'extensions')
        if os.path.isdir(extensions_subdir):
            # TRANSLATORS: An extension directory is a directory which contains extensions.
            print(_('Using extension directory %s') % extensions_subdir)
            self.extensions_dirs.append(extensions_subdir)

    def _try_init_sound(self):
        for _ in range(30):
            if pygame.mixer and pygame.mixer.get_init():
                return True
            time.sleep(0.1)
            try:
                pygame.mixer.init()
            except pygame.error:
                pass
        return pygame.mixer and pygame.mixer.get_init()

    def _load_resources(self, args):
        if not pygame.font:
            print(_('Error: pygame fonts not available. Exiting.'), file=sys.stderr)
            sys.exit(1)
        self._sticky_mouse = args.sticky_mouse
        if not self._try_init_sound():
            print(_('Warning: Sound support not available.'), file=sys.stderr)
            self._sound_enabled = False
        else:
            self._sound_enabled = True
            self.sound_muted = args.mute
            sounds = self.load_items(
                self.glob_data(['.wav', '.ogg']),
                args.sound_blacklist,
                self.load_sound,
                _("All sounds failed to load."))

            self._add_sound_policy('deterministic', DeterministicPolicy(sounds))
            self._add_sound_policy('random', RandomPolicy(sounds, self._random))

        images = self.load_items(
            self.glob_data(['.gif', '.jpg', '.jpeg', '.png', '.tif', '.tiff']),
            args.image_blacklist,
            self.load_image,
            _("All images failed to load."))

        self._add_image_policy('font', FontImagePolicy(args.uppercase, self._random))
        self._add_image_policy('random', RandomPolicy(images, self._random))

        if _YAML_LOADED and args.extension:
            if self._sound_enabled:
                extension_sounds = self.load_items(
                    self.glob_extension(['.wav', '.ogg'], args.extension),
                    [],
                    self.load_sound,
                    _("All extension sounds failed to load."))
                self._add_sound_policy('named_file', NamedFilePolicy(extension_sounds))
            self._sound_mapper, self._image_mapper = self._get_extension_mappers(args.extension)
            print(_('Using extension "%s".') % args.extension)
        else:
            self._image_mapper = LegacyImageMapper()
            if self._sound_enabled:
                self._sound_mapper = LegacySoundMapper(args.deterministic_sounds)

    def _get_extension_mappers(self, extension_name: str):
        for extension_dir in self.extensions_dirs:
            extension_subdir = os.path.join(extension_dir, extension_name)
            event_map_file_name = os.path.join(extension_subdir, 'event_map.yaml')
            if not os.path.exists(event_map_file_name):
                continue
            with open(event_map_file_name) as event_map_file:
                event_map = yaml.safe_load(event_map_file)
                for k in event_map:
                    if k not in ['apiVersion', 'image', 'sound']:
                        raise ResourceLoadException(event_map_file_name, 'unrecognized key %s' % k)
                apiVersion = event_map.get('apiVersion', 'undefined')
                if apiVersion not in ['0', 0]:
                    raise ResourceLoadException(event_map_file_name, 'Unrecognized API version %s' % apiVersion)
                image_map = event_map.get('image', {})
                sound_map = event_map.get('sound', {})
                return DeclarativeMapper(sound_map), DeclarativeMapper(image_map)
        raise ResourceLoadException(os.path.join(extension_name, 'event_map.yaml'), 'File not found.')

    def run(self):
        """
        Main application entry point.
        """
        program_base = os.path.dirname(os.path.realpath(sys.argv[0]))
        self._add_base_dir(program_base)
        self._add_base_dir(os.path.join(os.path.dirname(program_base), 'share', 'bambam'))
        self._add_base_dir(os.getenv('XDG_DATA_HOME', os.path.expanduser('~/.local/share/bambam')))

        parser = argparse.ArgumentParser(
            description=_('Keyboard mashing and doodling game for babies and toddlers.'))
        if not _YAML_LOADED:
            print(_('Warning: PyYAML not available, extension support disabled.'), file=sys.stderr)
        else:
            parser.add_argument('-e', '--extension', help=_('Use the specified extension.'))
        parser.add_argument('-u', '--uppercase', action='store_true',
                            help=_('Show UPPER-CASE letters.'))
        parser.add_argument('--sound_blacklist', action='append', default=[],
                            help=_('List of sound filename patterns to never play.'))
        parser.add_argument('--image_blacklist', action='append', default=[],
                            help=_('List of image filename patterns to never show.'))
        parser.add_argument('-d', '--deterministic-sounds', action='store_true',
                            help=_('Produce same sounds on same key presses.'))
        parser.add_argument('-D', '--dark', action='store_true',
                            help=_('Use a dark background instead of a light one.'))
        parser.add_argument('-m', '--mute', action='store_true',
                            help=_('Start muted.'))
        parser.add_argument('--sticky-mouse', action='store_true',
                            help=_('Start with sticky mouse buttons enabled.'))
        parser.add_argument('--wayland-ok', action='store_true',
                            help=_('Do not prevent running under Wayland.'))
        parser.add_argument('--in-dedicated-session', action='store_true',
                            help=argparse.SUPPRESS)
        parser.add_argument('--trace', action='store_true',
                            help=_('Print detailed messages about game internals.'))
        args = parser.parse_args()

        log_level = logging.DEBUG if args.trace else logging.INFO
        logging.basicConfig(level=log_level, format="%(asctime)s %(levelname)s %(name)s: %(message)s")
        pygame.init()

        pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
        # TRANSLATORS: Main game window name.
        pygame.display.set_caption(_('Bam Bam'))

        self._load_resources(args)
        self._prepare_screen(args)

        pygame.event.set_grab(True)
        if hasattr(pygame.event, 'set_keyboard_grab'):
            pygame.event.set_keyboard_grab(True)

        clock = pygame.time.Clock()
        if args.in_dedicated_session:
            self._prepare_welcome_message(dedicated_session=True)
        elif not args.wayland_ok and (os.getenv('WAYLAND_DISPLAY') or os.getenv('XDG_SESSION_TYPE') == 'wayland'):
            self._prepare_wayland_warning()
            poll_for_any_key_press(clock)
            sys.exit(1)
        else:
            self._prepare_welcome_message(dedicated_session=False)
        poll_for_any_key_press(clock)
        self.screen.blit(self.background, (0, 0))
        _show_mouse()
        pygame.display.flip()

        init_joysticks()

        game_mode_on = True
        mouse_pressed = False
        while True:
            clock.tick(60)
            for event in pygame.event.get():
                if event.type == QUIT:
                    sys.exit(0)

                elif event.type == KEYDOWN or event.type == pygame.JOYBUTTONDOWN:
                    self._bump_event_count()
                    self.process_keypress(event)

                elif event.type == MOUSEMOTION:
                    self._bump_event_count()
                    if mouse_pressed and game_mode_on == True:
                        self.draw_dot()
                        pygame.display.flip()

                elif event.type == MOUSEBUTTONDOWN and game_mode_on == True:
                    self._bump_event_count()
                    self.draw_dot()
                    if self._sticky_mouse:
                        mouse_pressed = not mouse_pressed
                    else:
                        mouse_pressed = True
                    pygame.display.flip()

                elif event.type == MOUSEBUTTONUP:
                    self._bump_event_count()
                    if not self._sticky_mouse:
                        mouse_pressed = False

    def _bump_event_count(self):
        self._event_count = (self._event_count + 1) % (self._HUE_SPACE * 2)

def _map_and_select(event, mapper, policies):
    policy_name, policy_args = mapper.map(event)
    policy = policies[policy_name]
    if not policy_args:
        policy_args = []
    return policy.select(event, *policy_args)

def _show_mouse():
    # In session mode, when display manager hides mouse cursor,
    # pygame tends to get confused about its visibility.
    # Changing it back and forth seems to help.
    # Also set it to a little hand while at it.
    # We also do this when not in session mode for consistency.
    pygame.mouse.set_visible(True)
    pygame.mouse.set_visible(False)
    pygame.mouse.set_cursor(pygame.SYSTEM_CURSOR_HAND)
    pygame.mouse.set_visible(True)


class CollectionPolicyBase:
    def __init__(self, named_things):
        self._things = []
        self._things_by_file_name = {}
        for name, thing in named_things:
            self._things.append(thing)
            self._things_by_file_name[name] = thing

    def select(self, event, *args):
        raise NotImplementedError()


class DeterministicPolicy(CollectionPolicyBase):
    def select(self, event):
        thing_idx = event.key % len(self._things)
        return self._things[thing_idx]


class NamedFilePolicy(CollectionPolicyBase):
    def select(self, _, file_name):
        return self._things_by_file_name[file_name]


class RandomPolicy(CollectionPolicyBase):
    def __init__(self, named_things, random_generator):
        super().__init__(named_things)
        self._random = random_generator

    def select(self, *_):
        choice = self._random.choice(self._things)
        logging.debug('Selected %s from %d possibilities.', choice, len(self._things))
        return choice


class FontImagePolicy:
    COLORS = (
        (0, 0, 255), (255, 0, 0), (255, 255, 0),
        (255, 0, 128), (0, 0, 128), (0, 255, 0),
        (255, 128, 0), (255, 0, 255), (0, 255, 255)
    )

    def __init__(self, upper_case: bool, random_generator) -> None:
        self._upper_case = upper_case
        self._random = random_generator

    def select(self, event):
        font = pygame.font.Font(None, 256)
        char = event.unicode
        if self._upper_case:
            char = char.upper()
        color = self._random.choice(self.COLORS)
        logging.debug('Selected color %s for char %s.', color, char)
        return font.render(char, 1, color)
class LegacySoundMapper:

    def __init__(self, deterministic_sounds: bool) -> None:
        self._deterministic_sounds = deterministic_sounds

    def map(self, event):
        if self._deterministic_sounds:
            if event.type == KEYDOWN:
                return "deterministic", None
            return "random", None
        else:
            return "random", None

class DeclarativeMapper:

    def __init__(self, spec):
        self._spec = spec

    def map(self, event):
        for step in self._spec:
            if 'check' in step:
                check_list = step['check']
                if not self._match_list(event, check_list):
                    continue
            return step['policy'], step.get('args', None)
        raise Exception('event %s matched no step in spec %s' % (
            event, self._spec))

    @classmethod
    def _match_list(cls, event, check_list):
        return all(cls._match_check(event, check) for check in check_list)

    @classmethod
    def _match_check(cls, event, check):
        if len(check) != 1:
            raise ValueError('only one key permitted in checks, found %s' % check.keys())
        if 'type' in check:
            t = check['type']
            if t == 'KEYDOWN':
                return event.type == KEYDOWN
            else:
                raise ValueError('only supported check type is currently KEYDOWN')
        elif 'unicode' in check:
            u = check['unicode']
            if len(u) != 1:
                raise ValueError('only one key is permitted in unicode check, found %s' % u.keys())
            if 'value' in u:
                return event.unicode == u['value']
            elif 'isalpha' in u:
                return str(event.unicode.isalpha()) == str(u['isalpha'])
            elif 'isdigit' in u:
                return str(event.unicode.isdigit()) == str(u['isdigit'])
            else:
                raise ValueError('unsupported key in unicode check: %s' % u.keys())
        else:
            raise ValueError('only checks for type and unicode are curerntly supported, found %s' % check.keys())

class LegacyImageMapper:

    def map(self, event):
        if event.type == pygame.KEYDOWN and (event.unicode == "1"): 
            #change to only include specific images 
            print("hello")
        elif event.type == pygame.KEYDOWN and (event.unicode.isalpha() or event.unicode.isdigit()):
            return "random", None
        else:
            return "random", None

def main():
    gettext.install('bambam')
    try:
        bambam = Bambam()
        bambam.run()
    except BambamException as e:
        print(e, file=sys.stderr)
        sys.exit(1)

if __name__ == '__main__':
    main()